/* empty css             *//* empty css                */import"./el-tab-pane-l0sNRNKZ.js";/* empty css                 *//* empty css                   *//* empty css                 *//* empty css                        *//* empty css                  */import{d as V,r,v as g,w as s,a as l,f as o,E as w,x as k,u as d,i as b,y,e as x,_,b as f,c as B,H as z,I as $}from"./index-BrD9HEJJ.js";const C=V({__name:"BorderRadius",setup(v){const a=r(50),n=r(50),t=r(50),i=r(50);return(p,e)=>{const c=k,m=w;return x(),g(m,{class:"box",direction:"vertical",size:"large",alignment:"flex-start"},{default:s(()=>[e[8]||(e[8]=l("div",null,"比较常见的设置方式就是设置像素，像素就代表了每个角对应的圆的半径，我个人理解就像是先贴合每个角切出对应圆角大小的正方形，然后以对角为圆心做一个半圆，使用这个半圆去切容器的角，得到的圆弧就是圆角。也可以设置百分比，设置一个数就代表水平垂直的百分比都是一个值。设置百分比为 10% / 20% 就代表，四个圆角的水平半径为长度的10%，四个圆角的垂直半径为长度的20%",-1)),o(m,null,{default:s(()=>[e[4]||(e[4]=l("span",{class:"label"}," border-top-left-radius: ",-1)),o(c,{modelValue:d(a),"onUpdate:modelValue":e[0]||(e[0]=u=>b(a)?a.value=u:null),min:0,max:100,size:"large",class:"silder","show-input":""},null,8,["modelValue"])]),_:1,__:[4]}),o(m,null,{default:s(()=>[e[5]||(e[5]=l("span",{class:"label"}," border-top-right-radius: ",-1)),o(c,{modelValue:d(n),"onUpdate:modelValue":e[1]||(e[1]=u=>b(n)?n.value=u:null),min:0,max:100,size:"large",class:"silder","show-input":""},null,8,["modelValue"])]),_:1,__:[5]}),o(m,null,{default:s(()=>[e[6]||(e[6]=l("span",{class:"label"}," border-bottom-left-radius: ",-1)),o(c,{modelValue:d(t),"onUpdate:modelValue":e[2]||(e[2]=u=>b(t)?t.value=u:null),min:0,max:100,size:"large",class:"silder","show-input":""},null,8,["modelValue"])]),_:1,__:[6]}),o(m,null,{default:s(()=>[e[7]||(e[7]=l("span",{class:"label"}," border-bottom-right-radius: ",-1)),o(c,{modelValue:d(i),"onUpdate:modelValue":e[3]||(e[3]=u=>b(i)?i.value=u:null),min:0,max:100,size:"large",class:"silder","show-input":""},null,8,["modelValue"])]),_:1,__:[7]}),l("div",{class:"demo",style:y({borderRadius:`${d(a)}px ${d(n)}px ${d(i)}px ${d(t)}px`})},null,4)]),_:1,__:[8]})}}}),E=_(C,[["__scopeId","data-v-fd72967d"]]),I=V({__name:"Background",setup(v){return r(50),r(50),r(50),r(50),(a,n)=>{const t=w;return x(),g(t,{class:"container",direction:"vertical",size:"large",alignment:"flex-start"},{default:s(()=>n[0]||(n[0]=[l("div",null,"背景的设置主要就是可以使用纯色、图片、渐变，这里主要演示渐变，图片的话之前有很长一段时间流行过雪碧图，也就是一张图上放着很多图标，然后通过背景图片，修改它的position去更换图标，不过自从字体图标流行之后便用的比较少了，svg图还是更好用一点。图片的背景尺寸常用的就是cover和contain，区别就在于前者通常是以放大图片为主，使得图片的宽高都能贴合到容器上，超出部分不展示，后者则往往是缩小图片，使得图片能完整展示，容器上下或者左右会有空余空间。不过相同点就是两者都会保留图片的宽高比。渐变的话主要是线性渐变和径向渐变，通俗一点理解就是前者是在一条线上去变化，后者就是一个点散发到周边，有点像点光源的感觉。",-1),l("div",{class:"box box-1"},null,-1),l("div",{class:"box box-2"},null,-1),l("div",null,"有一次无意中发现border其实也可以使用渐变，所以也弄一个效果看看，不过就是border使用渐变之后border-radius无效了",-1),l("div",{class:"box box-3"},null,-1)])),_:1,__:[0]})}}}),R=_(I,[["__scopeId","data-v-90f449db"]]),U={};function N(v,a){const n=w;return x(),g(n,{class:"container",direction:"vertical",size:"large",alignment:"flex-start"},{default:s(()=>a[0]||(a[0]=[l("div",null,"动画主要是分为帧动画和过渡动画，前者使用@keyframe结合animation来定义动画效果，后者则是使用transtion来定义过渡效果",-1),l("div",null,"使用自带的linear函数，就是平滑的线性动画",-1),l("div",{class:"box box-1"},null,-1),l("div",null,"使用贝塞尔曲线实现的动画函数就会变得更有活力",-1),l("div",{class:"box box-2"},null,-1),l("div",null,"使用steps函数实现的动画，就是一步步的来，可以用来实现无js的纯css轮播图",-1),l("div",{class:"box box-3"},[l("div",{class:"item item-1"}),l("div",{class:"item item-2"}),l("div",{class:"item item-3"})],-1),l("div",null,"过渡动画一般用于悬浮交互上比较多，比如下面，鼠标悬浮时会有一个圆角效果",-1),l("div",{class:"box box-4"},null,-1)])),_:1,__:[0]})}const T=_(U,[["render",N],["__scopeId","data-v-86c8c0c0"]]),h={};function F(v,a){const n=w;return x(),g(n,{class:"container",direction:"vertical",size:"large",alignment:"flex-start"},{default:s(()=>a[0]||(a[0]=[l("div",null,"先看盒模型，目前主流的盒模型分为border-box和content-box，也很好理解，前者的width=contentwidth + padding + border，后者就是width = contentwidth，后者的实际宽度在存在padding和border的前提下是比定义的width要更大的",-1),l("div",{class:"box box-1"}," border-box，width: 150px, height: 150px, padding: 10px, border: 10px ",-1),l("div",{class:"box box-2"}," content-box，width: 150px, height: 150px, padding: 10px, border: 10px ",-1),l("div",null,"再来看看流式布局，流式布局内部的块级元素会从上往下排放，行内元素则会从左往右排放，默认的布局就是流式布局",-1),l("div",null,"谈到了流式布局，就不得不提脱离常规流式布局的方法，常见的就是浮动和定位",-1),l("div",{class:"box"},[l("div",{class:"float"},"浮动元素"),f(" 会打破常规的流式布局，文字遇到浮动的元素时，都会腾出空间保证文字能全部展示，常常用于文字排版上 ")],-1),l("div",{class:"box"},[l("div",{class:"absolute"},"定位元素"),f(" 一般都是浮在流式元素上方，通过z-index设定它的层级，与浮动区别比较大的就是，文字遇到浮动元素并不会改变其原有的排版方式 ")],-1),l("div",null,"而它之所以会脱离文档流，其实就是因为不管是浮动还是定位，其本质还是创建了一个BFC（块级格式化上下文），该上下文创建了一个新的布局环境，与其它内容分隔开来，而页面的根元素(html元素)实际上就是创建了一个BFC，用来给整个文档提供一个布局环境。而常见的创建bfc的情形除了上述两种外还有以下几种",-1),l("div",{class:"box inline-block"}," display: inline-block | table-cell | table-caption | table | table-row | table-row-group | table-header-group | table-footer-group | inline-table | flow-root ",-1),l("div",{class:"box overflow-hidden"}," overflow 值不为 visible 或 clip 的块级元素 ",-1),l("div",{class:"box flex"}," 弹性元素（display 值为 flex 或 inline-flex 元素的直接子元素），网格元素（display 值为 grid 或 inline-grid 元素的直接子元素） ",-1),l("div",{class:"box column"}," 多列容器（column-count 或 column-width 值不为 auto，且含有 column-count: 1 的元素）。 ",-1),l("div",{class:"box column"},[l("div",{class:"column-span"},"column-span 值为 all"),f(" 的元素始终会创建一个新的格式化上下文，即使该元素没有包裹在一个多列容器中 ")],-1),l("div",null,[f("而BFC最常用的两个场景就是清除浮动和阻止外边距重叠，需要注意的一个点是外边距折叠仅与垂直方向有关，左右两边的外边距是不会重叠的 "),l("span",{style:{margin:"30px"}},"margin: 30px"),l("span",{style:{margin:"30px"}},"margin: 30px")],-1),l("div",null,"目前用的最多的就是弹性盒子布局，要了解弹性盒子布局，主要就是弄清楚主轴和交叉轴以及flex-grow，flex-shrink，flex-basis代表的含义其实就差不多了",-1),l("div",null,"网格布局给我的感觉就是bootstrap中的col-*，将一行分成多列，用来实现页面的响应式布局感觉会很不错。不过直到bootstrap5，才开始支持css grid的实现，之前都是通过flex来模拟的",-1)])),_:1,__:[0]})}const L=_(h,[["render",F],["__scopeId","data-v-d64ef82c"]]),S=V({__name:"index",setup(v){const a=r("border-radius"),n=t=>{a.value=t.props.name};return(t,i)=>{const p=$,e=z;return x(),B("main",null,[i[1]||(i[1]=l("div",null,"css样式相关",-1)),o(e,{modelValue:d(a),"onUpdate:modelValue":i[0]||(i[0]=c=>b(a)?a.value=c:null),class:"demo-tabs",onTabClick:n},{default:s(()=>[o(p,{label:"圆角",name:"border-radius"},{default:s(()=>[o(E)]),_:1}),o(p,{label:"背景",name:"background"},{default:s(()=>[o(R)]),_:1}),o(p,{label:"动画",name:"animation"},{default:s(()=>[o(T)]),_:1}),o(p,{label:"盒模型和布局",name:"layout"},{default:s(()=>[o(L)]),_:1})]),_:1},8,["modelValue"])])}}}),M=_(S,[["__scopeId","data-v-4ca08ff2"]]);export{M as default};
