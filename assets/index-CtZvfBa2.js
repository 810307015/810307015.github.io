/* empty css                    *//* empty css                *//* empty css                  *//* empty css                   */import{d as z,r as _,e as h,y as k,w as l,g as s,u as c,i as v,a as e,z as B,A as S,q as I,p as f,f as g,_ as $,b as y,c as C,J as R,K as E}from"./index-I3cbXsue.js";const w=o=>(f("data-v-fd72967d"),o=o(),g(),o),U=w(()=>e("div",null,"比较常见的设置方式就是设置像素，像素就代表了每个角对应的圆的半径，我个人理解就像是先贴合每个角切出对应圆角大小的正方形，然后以对角为圆心做一个半圆，使用这个半圆去切容器的角，得到的圆弧就是圆角。也可以设置百分比，设置一个数就代表水平垂直的百分比都是一个值。设置百分比为 10% / 20% 就代表，四个圆角的水平半径为长度的10%，四个圆角的垂直半径为长度的20%",-1)),N=w(()=>e("span",{class:"label"}," border-top-left-radius: ",-1)),T=w(()=>e("span",{class:"label"}," border-top-right-radius: ",-1)),F=w(()=>e("span",{class:"label"}," border-bottom-left-radius: ",-1)),L=w(()=>e("span",{class:"label"}," border-bottom-right-radius: ",-1)),A=z({__name:"BorderRadius",setup(o){const a=_(50),n=_(50),i=_(50),u=_(50);return(b,d)=>{const m=S,x=I;return h(),k(x,{class:"box",direction:"vertical",size:"large",alignment:"flex-start"},{default:l(()=>[U,s(x,null,{default:l(()=>[N,s(m,{modelValue:c(a),"onUpdate:modelValue":d[0]||(d[0]=p=>v(a)?a.value=p:null),min:0,max:100,size:"large",class:"silder","show-input":""},null,8,["modelValue"])]),_:1}),s(x,null,{default:l(()=>[T,s(m,{modelValue:c(n),"onUpdate:modelValue":d[1]||(d[1]=p=>v(n)?n.value=p:null),min:0,max:100,size:"large",class:"silder","show-input":""},null,8,["modelValue"])]),_:1}),s(x,null,{default:l(()=>[F,s(m,{modelValue:c(i),"onUpdate:modelValue":d[2]||(d[2]=p=>v(i)?i.value=p:null),min:0,max:100,size:"large",class:"silder","show-input":""},null,8,["modelValue"])]),_:1}),s(x,null,{default:l(()=>[L,s(m,{modelValue:c(u),"onUpdate:modelValue":d[3]||(d[3]=p=>v(u)?u.value=p:null),min:0,max:100,size:"large",class:"silder","show-input":""},null,8,["modelValue"])]),_:1}),e("div",{class:"demo",style:B({borderRadius:`${c(a)}px ${c(n)}px ${c(u)}px ${c(i)}px`})},null,4)]),_:1})}}}),j=$(A,[["__scopeId","data-v-fd72967d"]]),V=o=>(f("data-v-90f449db"),o=o(),g(),o),q=V(()=>e("div",null,"背景的设置主要就是可以使用纯色、图片、渐变，这里主要演示渐变，图片的话之前有很长一段时间流行过雪碧图，也就是一张图上放着很多图标，然后通过背景图片，修改它的position去更换图标，不过自从字体图标流行之后便用的比较少了，svg图还是更好用一点。图片的背景尺寸常用的就是cover和contain，区别就在于前者通常是以放大图片为主，使得图片的宽高都能贴合到容器上，超出部分不展示，后者则往往是缩小图片，使得图片能完整展示，容器上下或者左右会有空余空间。不过相同点就是两者都会保留图片的宽高比。渐变的话主要是线性渐变和径向渐变，通俗一点理解就是前者是在一条线上去变化，后者就是一个点散发到周边，有点像点光源的感觉。",-1)),J=V(()=>e("div",{class:"box box-1"},null,-1)),K=V(()=>e("div",{class:"box box-2"},null,-1)),P=V(()=>e("div",null,"有一次无意中发现border其实也可以使用渐变，所以也弄一个效果看看，不过就是border使用渐变之后border-radius无效了",-1)),D=V(()=>e("div",{class:"box box-3"},null,-1)),G=z({__name:"Background",setup(o){return _(50),_(50),_(50),_(50),(a,n)=>{const i=I;return h(),k(i,{class:"container",direction:"vertical",size:"large",alignment:"flex-start"},{default:l(()=>[q,J,K,P,D]),_:1})}}}),H=$(G,[["__scopeId","data-v-90f449db"]]),M={},r=o=>(f("data-v-86c8c0c0"),o=o(),g(),o),O=r(()=>e("div",null,"动画主要是分为帧动画和过渡动画，前者使用@keyframe结合animation来定义动画效果，后者则是使用transtion来定义过渡效果",-1)),Q=r(()=>e("div",null,"使用自带的linear函数，就是平滑的线性动画",-1)),W=r(()=>e("div",{class:"box box-1"},null,-1)),X=r(()=>e("div",null,"使用贝塞尔曲线实现的动画函数就会变得更有活力",-1)),Y=r(()=>e("div",{class:"box box-2"},null,-1)),Z=r(()=>e("div",null,"使用steps函数实现的动画，就是一步步的来，可以用来实现无js的纯css轮播图",-1)),ee=r(()=>e("div",{class:"box box-3"},[e("div",{class:"item item-1"}),e("div",{class:"item item-2"}),e("div",{class:"item item-3"})],-1)),oe=r(()=>e("div",null,"过渡动画一般用于悬浮交互上比较多，比如下面，鼠标悬浮时会有一个圆角效果",-1)),se=r(()=>e("div",{class:"box box-4"},null,-1));function te(o,a){const n=I;return h(),k(n,{class:"container",direction:"vertical",size:"large",alignment:"flex-start"},{default:l(()=>[O,Q,W,X,Y,Z,ee,oe,se]),_:1})}const le=$(M,[["render",te],["__scopeId","data-v-86c8c0c0"]]),ae={},t=o=>(f("data-v-d64ef82c"),o=o(),g(),o),ne=t(()=>e("div",null,"先看盒模型，目前主流的盒模型分为border-box和content-box，也很好理解，前者的width=contentwidth + padding + border，后者就是width = contentwidth，后者的实际宽度在存在padding和border的前提下是比定义的width要更大的",-1)),de=t(()=>e("div",{class:"box box-1"}," border-box，width: 150px, height: 150px, padding: 10px, border: 10px ",-1)),ie=t(()=>e("div",{class:"box box-2"}," content-box，width: 150px, height: 150px, padding: 10px, border: 10px ",-1)),ce=t(()=>e("div",null,"再来看看流式布局，流式布局内部的块级元素会从上往下排放，行内元素则会从左往右排放，默认的布局就是流式布局",-1)),_e=t(()=>e("div",null,"谈到了流式布局，就不得不提脱离常规流式布局的方法，常见的就是浮动和定位",-1)),re=t(()=>e("div",{class:"box"},[e("div",{class:"float"},"浮动元素"),y(" 会打破常规的流式布局，文字遇到浮动的元素时，都会腾出空间保证文字能全部展示，常常用于文字排版上 ")],-1)),ue=t(()=>e("div",{class:"box"},[e("div",{class:"absolute"},"定位元素"),y(" 一般都是浮在流式元素上方，通过z-index设定它的层级，与浮动区别比较大的就是，文字遇到浮动元素并不会改变其原有的排版方式 ")],-1)),pe=t(()=>e("div",null,"而它之所以会脱离文档流，其实就是因为不管是浮动还是定位，其本质还是创建了一个BFC（块级格式化上下文），该上下文创建了一个新的布局环境，与其它内容分隔开来，而页面的根元素(html元素)实际上就是创建了一个BFC，用来给整个文档提供一个布局环境。而常见的创建bfc的情形除了上述两种外还有以下几种",-1)),me=t(()=>e("div",{class:"box inline-block"}," display: inline-block | table-cell | table-caption | table | table-row | table-row-group | table-header-group | table-footer-group | inline-table | flow-root ",-1)),be=t(()=>e("div",{class:"box overflow-hidden"}," overflow 值不为 visible 或 clip 的块级元素 ",-1)),xe=t(()=>e("div",{class:"box flex"}," 弹性元素（display 值为 flex 或 inline-flex 元素的直接子元素），网格元素（display 值为 grid 或 inline-grid 元素的直接子元素） ",-1)),ve=t(()=>e("div",{class:"box column"}," 多列容器（column-count 或 column-width 值不为 auto，且含有 column-count: 1 的元素）。 ",-1)),he=t(()=>e("div",{class:"box column"},[e("div",{class:"column-span"},"column-span 值为 all"),y(" 的元素始终会创建一个新的格式化上下文，即使该元素没有包裹在一个多列容器中 ")],-1)),fe=t(()=>e("div",null,[y("而BFC最常用的两个场景就是清除浮动和阻止外边距重叠，需要注意的一个点是外边距折叠仅与垂直方向有关，左右两边的外边距是不会重叠的 "),e("span",{style:{margin:"30px"}},"margin: 30px"),e("span",{style:{margin:"30px"}},"margin: 30px")],-1)),ge=t(()=>e("div",null,"目前用的最多的就是弹性盒子布局，要了解弹性盒子布局，主要就是弄清楚主轴和交叉轴以及flex-grow，flex-shrink，flex-basis代表的含义其实就差不多了",-1)),$e=t(()=>e("div",null,"网格布局给我的感觉就是bootstrap中的col-*，将一行分成多列，用来实现页面的响应式布局感觉会很不错。不过直到bootstrap5，才开始支持css grid的实现，之前都是通过flex来模拟的",-1));function we(o,a){const n=I;return h(),k(n,{class:"container",direction:"vertical",size:"large",alignment:"flex-start"},{default:l(()=>[ne,de,ie,ce,_e,re,ue,pe,me,be,xe,ve,he,fe,ge,$e]),_:1})}const Ve=$(ae,[["render",we],["__scopeId","data-v-d64ef82c"]]),ke=o=>(f("data-v-4ca08ff2"),o=o(),g(),o),Ie=ke(()=>e("div",null,"css样式相关",-1)),ye=z({__name:"index",setup(o){const a=_("border-radius"),n=i=>{a.value=i.props.name};return(i,u)=>{const b=E,d=R;return h(),C("main",null,[Ie,s(d,{modelValue:c(a),"onUpdate:modelValue":u[0]||(u[0]=m=>v(a)?a.value=m:null),class:"demo-tabs",onTabClick:n},{default:l(()=>[s(b,{label:"圆角",name:"border-radius"},{default:l(()=>[s(j)]),_:1}),s(b,{label:"背景",name:"background"},{default:l(()=>[s(H)]),_:1}),s(b,{label:"动画",name:"animation"},{default:l(()=>[s(le)]),_:1}),s(b,{label:"盒模型和布局",name:"layout"},{default:l(()=>[s(Ve)]),_:1})]),_:1},8,["modelValue"])])}}}),Ee=$(ye,[["__scopeId","data-v-4ca08ff2"]]);export{Ee as default};
